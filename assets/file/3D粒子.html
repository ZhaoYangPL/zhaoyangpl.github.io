<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI æ‰‹åŠ¿æ§åˆ¶ç²’å­å¤ªé˜³ç³»</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* UI é¢æ¿æ ·å¼ */
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            padding: 25px;
            background: rgba(20, 20, 35, 0.7); /* æ›´æ·±è‰²çš„èƒŒæ™¯ */
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0ff;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }

        h2 { margin: 0 0 20px 0; font-size: 20px; font-weight: 600; letter-spacing: 1px; color: #fff; text-align: center;}
        
        .control-group { margin-bottom: 20px; }
        .control-header { font-size: 13px; color: #8a8ab5; margin-bottom: 10px; display: block;}
        
        /* æŒ‰é’®ç½‘æ ¼ */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        
        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #c0c0e0;
            padding: 12px 10px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        button:hover { background: rgba(255, 255, 255, 0.15); transform: translateY(-2px); }
        /* ç‰¹æ®Šé«˜äº®æ ·å¼ */
        button.active.morph-mode { background: linear-gradient(135deg, #00d2ff, #3a7bd5); color: white; border: none; box-shadow: 0 4px 15px rgba(0, 210, 255, 0.4); }
        button.active.solar-mode { background: linear-gradient(135deg, #ff9900, #ff5e00); color: white; border: none; box-shadow: 0 4px 15px rgba(255, 153, 0, 0.4); }

        /* é¢œè‰²é€‰æ‹©å™¨ - ä»…åœ¨ç‰¹å®šæ¨¡å¼æ˜¾ç¤º */
        #color-control-group { transition: opacity 0.3s; }
        input[type="color"] {
            width: 100%; height: 40px; border: none; border-radius: 10px; cursor: pointer; background: transparent;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        #video-preview-container {
            position: absolute; bottom: 30px; left: 30px;
            width: 180px; height: 135px;
            border-radius: 15px; overflow: hidden;
            border: 3px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
        }
        #video-preview { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.8; }
        #hand-tracking-overlay {
            position: absolute; top: 10px; left: 10px; font-size: 12px; color: white; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 6px; pointer-events: none;
        }

        #status {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; text-align: center; pointer-events: none; transition: opacity 0.8s;
            text-shadow: 0 0 20px rgba(0, 210, 255, 0.8);
        }
        .hide { opacity: 0; pointer-events: none;}
        
        .fullscreen-btn { margin-top: 15px; width: 100%; background: rgba(255, 255, 255, 0.08); }
    </style>
</head>
<body>

    <div id="status">æ­£åœ¨å¯åŠ¨ç¥ç»è¿æ¥ä¸å…¨æ¯æŠ•å½±...<br><span style="font-size:14px; opacity:0.7; letter-spacing: 2px;">è¯·æˆäºˆæ‘„åƒå¤´æƒé™</span></div>

    <div id="video-preview-container">
        <div id="hand-tracking-overlay">AI æ‰‹åŠ¿è¿½è¸ªä¸­</div>
        <video id="video-preview" playsinline></video>
    </div>

    <div id="ui-container">
        <h2>æ˜Ÿé™…äº¤äº’ç³»ç»Ÿ</h2>
        
        <div class="control-group">
            <span class="control-header">å…¨æ¯æ¨¡å¼é€‰æ‹©</span>
            <div class="btn-grid" id="shape-buttons">
                <button onclick="setMode('solarsystem')" style="grid-column: span 2; font-weight: bold;">ğŸŒŒ å¤ªé˜³ç³» (æ–°)</button>
                
                <button onclick="setMode('heart')" class="active morph-mode">â¤ï¸ çˆ±å¿ƒ</button>
                <button onclick="setMode('sphere')">ğŸª è¡Œæ˜Ÿä½“</button>
                <button onclick="setMode('flower')">ğŸŒ¸ é‡å­èŠ±</button>
                <button onclick="setMode('spiral')">ğŸŒ€ æ—¶ç©ºç±»æ˜Ÿä½“</button>
                <button onclick="setMode('cube')">ğŸ§Š è¶…ç«‹æ–¹ä½“</button>
                <button onclick="setMode('fireworks')">ğŸ† æ˜Ÿäº‘çˆ†å‘</button>
            </div>
        </div>

        <div class="control-group" id="color-control-group">
            <span class="control-header">ç²’å­æ³¢é•¿ (é¢œè‰²)</span>
            <input type="color" id="color-picker" value="#00d2ff">
        </div>

        <div class="control-group" style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 12px;">
            <span class="control-header" style="margin-bottom: 5px;">æ‰‹åŠ¿é¥æµ‹çŠ¶æ€</span>
            <div id="hand-status" style="color:#00d2ff; font-size: 16px; font-weight: 600; margin-bottom: 8px;">ç­‰å¾…ä¿¡å·...</div>
            <div style="font-size: 12px; opacity: 0.6; line-height: 1.5;">
                âœ‹ ç§»åŠ¨æ‰‹æŒ: æ§åˆ¶æ—‹è½¬ä¸ç¿»åŠ¨<br>
                ğŸ‘‹ å¼ å¼€äº”æŒ‡: æ”¾å¤§æ˜Ÿç³»/æ‰©æ•£<br>
                ğŸ‘Œ æåˆæ‰‹æŒ‡: ç¼©å°æ˜Ÿç³»/èšåˆ
            </div>
        </div>

        <button class="fullscreen-btn" onclick="toggleFullScreen()">â›¶ æ²‰æµ¸å¼å…¨å±</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 1. Three.js åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        // ä½¿ç”¨æ›´æ·±é‚ƒçš„å¤ªç©ºèƒŒæ™¯é›¾
        scene.fog = new THREE.FogExp2(0x000005, 0.0015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- å…¨å±€çŠ¶æ€å˜é‡ ---
        let currentMode = 'morph'; // 'morph' (å½¢çŠ¶å˜æ¢) æˆ– 'solar' (å¤ªé˜³ç³»)
        let handInteractionFactor = 0; 
        let targetRotation = { x: 0, y: 0 };
        let isHandDetected = false; 
        let baseScale = 1; // ç”¨äºå¤ªé˜³ç³»çš„æ•´ä½“ç¼©æ”¾

        // ==========================================
        // === æ¨¡å¼ A: å˜å½¢ç²’å­ç³»ç»Ÿ (åŸæœ‰åŠŸèƒ½) ===
        // ==========================================
        const particleCount = 25000; // å¢åŠ ç²’å­æ•°ä»¥è·å¾—æ›´å¥½çš„æ•ˆæœ
        const morphGeometry = new THREE.BufferGeometry();
        const morphPositions = new Float32Array(particleCount * 3);
        const targetPositions = new Float32Array(particleCount * 3); 
        const baseTargetPositions = new Float32Array(particleCount * 3);

        for(let i = 0; i < particleCount * 3; i++) {
            morphPositions[i] = (Math.random() - 0.5) * 200;
            targetPositions[i] = morphPositions[i];
            baseTargetPositions[i] = morphPositions[i];
        }

        morphGeometry.setAttribute('position', new THREE.BufferAttribute(morphPositions, 3));

        const morphMaterial = new THREE.PointsMaterial({
            color: 0x00d2ff,
            size: 0.25,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.85,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const morphParticles = new THREE.Points(morphGeometry, morphMaterial);
        scene.add(morphParticles);

        // --- å½¢çŠ¶è®¡ç®—ç®—æ³• ---
        function getSpherePoint(r) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        function calculateShape(type) {
            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                const idx = i * 3;
                // ä¸ºäº†ç®€æ´ï¼Œè¿™é‡Œä½¿ç”¨äº†ç®€åŒ–çš„å•è¡Œå†™æ³•ï¼Œé€»è¾‘ä¸ä¹‹å‰ç›¸åŒ
                switch (type) {
                    case 'heart':
                        const t=Math.random()*6.28, r=Math.random(), s=1.2;
                        x=16*Math.pow(Math.sin(t),3)*s*Math.sqrt(r); 
                        y=(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))*s*Math.sqrt(r); 
                        z=(Math.random()-0.5)*8; break;
                    case 'sphere':
                        const p = getSpherePoint(18 + Math.random()*2); x=p.x;y=p.y;z=p.z; break;
                    case 'flower':
                        const ft=Math.random()*6.28, fr=18*Math.cos(6*ft)*Math.random();
                        x=fr*Math.cos(ft); y=fr*Math.sin(ft); z=(Math.random()-0.5)*8; break;
                    case 'spiral':
                        const st=i*0.08, sr=Math.sqrt(i)*0.15;
                        x=sr*Math.cos(st); y=(Math.random()-0.5)*(30-sr*0.5); z=sr*Math.sin(st); break;
                    case 'cube':
                        const cs=22; x=(Math.random()-0.5)*cs; y=(Math.random()-0.5)*cs; z=(Math.random()-0.5)*cs; break;
                    case 'fireworks':
                        const fp=getSpherePoint(Math.random()*40); x=fp.x; y=fp.y; z=fp.z; break;
                }
                baseTargetPositions[idx] = x; baseTargetPositions[idx+1] = y; baseTargetPositions[idx+2] = z;
            }
        }

        // ==========================================
        // === æ¨¡å¼ B: ç²’å­å¤ªé˜³ç³» (æ–°åŠŸèƒ½) ===
        // ==========================================
        const solarSystemGroup = new THREE.Group();
        scene.add(solarSystemGroup);
        solarSystemGroup.visible = false; // é»˜è®¤éšè—

        // è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºç²’å­çƒä½“ï¼ˆç”¨äºè¡Œæ˜Ÿå’Œå¤ªé˜³ï¼‰
        function createParticleSphere(radius, count, color, size) {
            const geom = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                const p = getSpherePoint(radius * (0.9 + Math.random()*0.2)); // ç¨å¾®ä¸€ç‚¹åšåº¦éšæœº
                pos[i*3] = p.x; pos[i*3+1] = p.y; pos[i*3+2] = p.z;
            }
            geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: color, size: size, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false
            });
            return new THREE.Points(geom, mat);
        }

        // è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºè½¨é“çº¿
        function createOrbit(radius, color) {
            const points = [];
            const segments = 128;
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                points.push(new THREE.Vector3(Math.cos(theta) * radius, 0, Math.sin(theta) * radius));
            }
            const geom = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.3 });
            return new THREE.LineLoop(geom, mat);
        }

        // 1. åˆ›å»ºå¤ªé˜³
        const sun = createParticleSphere(8, 8000, 0xffaa00, 0.6); // æ›´å¤§ã€æ›´å¯†ã€æ›´äº®çš„å¤ªé˜³
        solarSystemGroup.add(sun);

        // 2. åˆ›å»ºè¡Œæ˜Ÿæ•°æ®ç»“æ„
        const planets = [];
        const planetData = [
            { name: 'Mercury', r: 1.5, dist: 14, color: 0xaaaaaa, speed: 0.04 },
            { name: 'Venus', r: 2.2, dist: 20, color: 0xffcc66, speed: 0.03 },
            { name: 'Earth', r: 2.4, dist: 28, color: 0x00d2ff, speed: 0.025 },
            { name: 'Mars', r: 2.0, dist: 36, color: 0xff4400, speed: 0.02 },
            { name: 'Jupiter', r: 5.0, dist: 55, color: 0xdba35c, speed: 0.01 },
            { name: 'Saturn', r: 4.5, dist: 75, color: 0xfcdc9c, speed: 0.008, hasRing: true },
        ];

        planetData.forEach(data => {
            // åˆ›å»ºè¡Œæ˜Ÿæ—‹è½¬è½´å¿ƒç‚¹ (Pivot)
            const pivot = new THREE.Group();
            solarSystemGroup.add(pivot);

            // åˆ›å»ºè¡Œæ˜Ÿä½“
            const planetMesh = createParticleSphere(data.r, data.r * 800, data.color, 0.3);
            planetMesh.position.x = data.dist; // è®¾ç½®è½¨é“è·ç¦»
            pivot.add(planetMesh);

            // åˆ›å»ºå¯è§†è½¨é“
            solarSystemGroup.add(createOrbit(data.dist, data.color));

            // ç‰¹æ®Šå¤„ç†ï¼šåœŸæ˜Ÿå…‰ç¯
            if (data.hasRing) {
                const ringGeom = new THREE.BufferGeometry();
                const ringPos = new Float32Array(4000 * 3);
                for(let i=0; i<4000; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const rad = data.r * 1.4 + Math.random() * data.r * 1.5; // å…‰ç¯åŠå¾„èŒƒå›´
                    ringPos[i*3] = Math.cos(ang) * rad;
                    ringPos[i*3+1] = (Math.random()-0.5) * 0.5; // è–„è–„ä¸€å±‚
                    ringPos[i*3+2] = Math.sin(ang) * rad;
                }
                ringGeom.setAttribute('position', new THREE.BufferAttribute(ringPos, 3));
                const ringMat = new THREE.PointsMaterial({ color: 0xc0b090, size: 0.2, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
                const ring = new THREE.Points(ringGeom, ringMat);
                planetMesh.add(ring); // åŠ åˆ°è¡Œæ˜ŸMeshä¸Š
                ring.rotation.x = 0.5; // å€¾æ–œå…‰ç¯
            }

            planets.push({ pivot: pivot, mesh: planetMesh, speed: data.speed, selfRotationSpeed: Math.random() * 0.02 + 0.01 });
        });


        // ==========================================
        // === äº¤äº’é€»è¾‘æ§åˆ¶ ===
        // ==========================================
        
        // åˆ‡æ¢æ¨¡å¼ä¸å½¢çŠ¶
        window.setMode = function(modeType) {
            const colorControl = document.getElementById('color-control-group');
            const buttons = document.querySelectorAll('#shape-buttons button');

            if (modeType === 'solarsystem') {
                // åˆ‡æ¢åˆ°å¤ªé˜³ç³»æ¨¡å¼
                currentMode = 'solar';
                morphParticles.visible = false;
                solarSystemGroup.visible = true;
                // å¤ªé˜³ç³»æ¨¡å¼ä¸‹éšè—é¢œè‰²é€‰æ‹©å™¨ï¼Œå› ä¸ºè¡Œæ˜Ÿæœ‰è‡ªå·±çš„é¢œè‰²
                colorControl.style.opacity = 0; 
                // é‡ç½®ç¼©æ”¾
                baseScale = 1;

            } else {
                // åˆ‡æ¢åˆ°å˜å½¢æ¨¡å¼
                currentMode = 'morph';
                morphParticles.visible = true;
                solarSystemGroup.visible = false;
                colorControl.style.opacity = 1;
                calculateShape(modeType);
            }
            
            // æ›´æ–° UI æŒ‰é’®çŠ¶æ€
            buttons.forEach(btn => {
                btn.classList.remove('active', 'morph-mode', 'solar-mode');
                if (modeType === 'solarsystem' && btn.innerText.includes('å¤ªé˜³ç³»')) {
                    btn.classList.add('active', 'solar-mode');
                } else if (currentMode === 'morph') {
                     const map = {'heart':'çˆ±å¿ƒ','sphere':'è¡Œæ˜Ÿ','flower':'èŠ±æœµ','spiral':'ç¦…æ„','cube':'ç«‹æ–¹ä½“','fireworks':'çƒŸèŠ±'};
                     if(btn.innerText.includes(map[modeType])) btn.classList.add('active', 'morph-mode');
                }
            });
        };

        // é¢œè‰²ä¸å…¨å±
        document.getElementById('color-picker').addEventListener('input', (e) => morphMaterial.color.set(e.target.value));
        window.toggleFullScreen = function() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        };

        // ==========================================
        // === AI æ‰‹åŠ¿è¯†åˆ«æ ¸å¿ƒ ===
        // ==========================================
        const handStatusText = document.getElementById('hand-status');

        function onResults(results) {
            document.getElementById('status').classList.add('hide');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                const thumb = landmarks[4];
                const index = landmarks[8];
                const wrist = landmarks[0];

                // 1. æåˆè®¡ç®— (æ§åˆ¶ç¼©æ”¾/æ‰©æ•£)
                const distance = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));

                if (distance < 0.05) {
                    handStatusText.html = "ğŸ‘Œ æåˆ <span style='font-size:12px'>(èšåˆ/ç¼©å°)</span>";
                    handStatusText.style.color = "#ffdd00";
                    // æåˆæ—¶ï¼ŒInteractionFactor å˜è´Ÿ
                    handInteractionFactor = THREE.MathUtils.lerp(handInteractionFactor, -1, 0.1);
                } else if (distance > 0.15) {
                    handStatusText.innerHTML = "ğŸ‘‹ å¼ å¼€ <span style='font-size:12px'>(æ‰©æ•£/æ”¾å¤§)</span>";
                    handStatusText.style.color = "#00ff88";
                    // å¼ å¼€æ—¶ï¼ŒInteractionFactor å˜æ­£
                    handInteractionFactor = THREE.MathUtils.lerp(handInteractionFactor, 2, 0.1);
                } else {
                    handStatusText.innerText = "âœ‹ å·²è¿æ¥ - ç§»åŠ¨æ§åˆ¶è§†è§’";
                    handStatusText.style.color = "#00d2ff";
                    handInteractionFactor = THREE.MathUtils.lerp(handInteractionFactor, 0, 0.1);
                }

                // 2. æ—‹è½¬æ˜ å°„ (æ‰‹è…•ä½ç½®æ§åˆ¶æ—‹è½¬)
                // æ˜ å°„èŒƒå›´æ‰©å¤§ï¼Œè®©æ—‹è½¬æ›´çµæ•
                targetRotation.y = (wrist.x - 0.5) * 5; 
                targetRotation.x = (wrist.y - 0.5) * 4; 

            } else {
                isHandDetected = false;
                handStatusText.innerText = "ç­‰å¾…ä¿¡å·...";
                handStatusText.style.color = "#555";
                handInteractionFactor = THREE.MathUtils.lerp(handInteractionFactor, 0, 0.05);
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const videoElement = document.getElementById('video-preview');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start().then(() => console.log("æ‘„åƒå¤´å·²å¯åŠ¨")).catch(err => document.getElementById('status').innerHTML = "é”™è¯¯ï¼šæ— æ³•è®¿é—®æ‘„åƒå¤´æƒé™");

        // ==========================================
        // === ä¸»åŠ¨ç”»å¾ªç¯ (æ ¸å¿ƒæ¸²æŸ“é€»è¾‘) ===
        // ==========================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // --- é€šç”¨æ—‹è½¬é€»è¾‘ (é€‚ç”¨äºä¸¤ç§æ¨¡å¼) ---
            let activeObject = currentMode === 'solar' ? solarSystemGroup : morphParticles;

            if (isHandDetected) {
                // æ‰‹åŠ¿æ§åˆ¶æ—‹è½¬
                activeObject.rotation.y += (targetRotation.y - activeObject.rotation.y) * 0.08;
                activeObject.rotation.x += (targetRotation.x - activeObject.rotation.x) * 0.08;
            } else {
                // å¾…æœºè‡ªåŠ¨æ…¢æ—‹
                activeObject.rotation.y += 0.0015;
                activeObject.rotation.x += (0 - activeObject.rotation.x) * 0.05;
            }

            // --- æ¨¡å¼å·®å¼‚åŒ–æ¸²æŸ“ ---
            if (currentMode === 'solar') {
                // >>> å¤ªé˜³ç³»æ¨¡å¼åŠ¨ç”» <<<
                
                // 1. è¡Œæ˜Ÿå…¬è½¬ä¸è‡ªè½¬
                sun.rotation.y = time * 0.05; // å¤ªé˜³è‡ªè½¬
                planets.forEach(p => {
                    p.pivot.rotation.y += p.speed; // å…¬è½¬
                    p.mesh.rotation.y += p.selfRotationSpeed; // è‡ªè½¬
                });

                // 2. æ•´ä½“ç¼©æ”¾æ§åˆ¶ (åŸºäºæ‰‹åŠ¿æåˆ)
                // handInteractionFactor èŒƒå›´å¤§æ¦‚åœ¨ -1 åˆ° 2 ä¹‹é—´
                // æˆ‘ä»¬å°†å…¶æ˜ å°„åˆ° 0.5å€ åˆ° 3å€ çš„ç¼©æ”¾èŒƒå›´
                let targetScale = 1 + handInteractionFactor * 0.8;
                // é™åˆ¶æœ€å°æœ€å¤§ç¼©æ”¾å€¼
                targetScale = THREE.MathUtils.clamp(targetScale, 0.4, 3.5);
                // å¹³æ»‘ç¼©æ”¾
                baseScale = THREE.MathUtils.lerp(baseScale, targetScale, 0.1);
                solarSystemGroup.scale.set(baseScale, baseScale, baseScale);

            } else {
                // >>> å˜å½¢æ¨¡å¼åŠ¨ç”» (åŸé€»è¾‘) <<<
                const positionsAttribute = morphGeometry.attributes.position;
                const array = positionsAttribute.array;
                for(let i = 0; i < particleCount; i++) {
                    const idx = i * 3;
                    let tx = baseTargetPositions[idx], ty = baseTargetPositions[idx+1], tz = baseTargetPositions[idx+2];
                    // çˆ†ç‚¸/æ”¶ç¼©
                    if (Math.abs(handInteractionFactor) > 0.1) {
                        const dist = Math.sqrt(tx*tx + ty*ty + tz*tz) + 0.1;
                        const offset = handInteractionFactor * (dist * 0.6 + Math.random() * 3);
                        tx += (tx/dist)*offset; ty += (ty/dist)*offset; tz += (tz/dist)*offset;
                    }
                    // å¹³æ»‘æ’å€¼é£å‘ç›®æ ‡
                    array[idx] += (tx - array[idx])*0.08; array[idx+1] += (ty - array[idx+1])*0.08; array[idx+2] += (tz - array[idx+2])*0.08;
                }
                positionsAttribute.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        // å¯åŠ¨
        calculateShape('heart'); // é»˜è®¤åˆå§‹å½¢çŠ¶
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>