# 函数依赖

| **概念**         | **符号表示**               | **人话解释**                                                 | **生活例子 (场景：学生选课)**                                |
| ---------------- | -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **完全函数依赖** | $(X,Y) \to Z$              | **“缺一不可”** 必须靠几个属性**合伙**才能确定结果，少一个都不行。 | **(学号, 课程) $\to$ 分数** 只知道学号？不知道哪门课的分数。 只知道课程？不知道是谁的分数。 必须两个都知道，才能查到分数。 |
| **部分函数依赖** | $(X,Y) \to Z$ 但 $X \to Z$ | **“抱大腿 / 搭便车”** 虽然写在一起，但其实结果只依赖主键里的**一部分**。 | **(学号, 课程) $\to$ 学生姓名** 其实只要知道“学号”就知道姓名了，根本不需要“课程”来帮忙。姓名这就是在搭便车。 |
| **传递函数依赖** | $X \to Y \to Z$            | **“隔山打牛”** A决定B，B又决定C，所以A间接决定C。            | **学号 $\to$ 学院 $\to$ 院长** 学号决定了这个学生在哪个学院，学院决定了谁是院长。 所以学号间接决定了院长。 |

# 五种码

| **概念**                   | **人话解释**                                                 | **特点**                                   | **例子**                                                     |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------ | ------------------------------------------------------------ |
| **超码** (Super Key)       | **“唯一的，但可能罗嗦”** 能唯一标识一行数据，但可能包含多余的废话。 | 只要唯一就行，**不求最简**。               | **(学号)** 是超码（唯一）。 **(学号, 姓名)** 也是超码（虽然姓名有点多余，但加在一起肯定还是唯一的）。 |
| **候选码** (Candidate Key) | **“唯一的，且最精简”** 超码的“瘦身版”。既能唯一标识，又没有多余字段。 | **唯一 + 最小化**。 可能有好几个。         | **(学号)** 是候选码。 如果**身份证号**也在表里，那**(身份证号)** 也是候选码。 |
| **主码** (Primary Key)     | **“被选中的那个”** 从候选码里挑一个出来做老大，作为表的主要ID。 | 每个表**只能有一个**。                     | 从学号和身份证号里，学校选择了 **(学号)** 作为主码。         |
| **外码** (Foreign Key)     | **“别家的人”** 在我这张表里只是个普通字段，但在**另一张表**里它是主码。 | 用来建立**表与表的联系**。                 | 在“成绩表”里存了“学号”，这个“学号”其实是“学生表”的主码。那它在成绩表里就是外码。 |
| **全码** (All-Key)         | **“全员皆兵”** 所有属性加起来才能唯一标识一行数据，缺一个都不行。 | 没有单独的主键，**所有字段一起**构成主键。 | **(教师, 课程, 参考书)** 假设一个老师教一门课可以用多本书。想区分每一行，三个字段必须全都要。 |

# 字段的属性

| **概念**                           | **人话解释**                                | **身份地位**                                                 |
| ---------------------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| **主属性** (Prime Attribute)       | **“VIP 成员”** 构成候选码的那些字段。       | 只要它参与了候选码（哪怕只是组合键的一部分），它就是主属性。 |
| **非主属性** (Non-prime Attribute) | **“普通群众”** 不包含在任何候选码里的字段。 | 完全依赖于主属性才能找到它。                                 |

# 规范化

| **范式** | **核心口号 (人话版)**                     | **解决什么痛点？**                                           | **改造前 (错误示范)**                                        | **改造后 (正确做法)**                                  |
| -------- | ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------ |
| **1NF**  | **拒绝大杂烩** (原子性)                   | **格子太挤** 一个格子里塞了多条数据，没法查。                | **一行数据：** 张三，"数学, 英语"                            | **拆成两行：** 张三，数学 张三，英语                   |
| **2NF**  | **拒绝搭便车** (消灭部分依赖)             | **混吃混喝** 非主键字段只依赖组合主键的*一部分*。            | **主键(学生+课程)：** 张三，数学，*18岁* *(年龄跟课程无关，却重复存)* | **拆表：** 表1：学生 -> 年龄 表2：(学生+课程) -> 成绩  |
| **3NF**  | **拒绝隔山打牛** (消灭传递依赖)           | **层层转包** A决定B，B决定C，导致C跟着A跑。                  | **依赖链：** 学生 -> 学院 -> *学院电话* *(电话其实是找学院的)* | **拆表：** 表1：学生 -> 学院 表2：学院 -> 电话         |
| **BCNF** | **拒绝喧宾夺主** (消灭主属性对非码的依赖) | **小鬼当家** 虽然满足3NF，但主键里的某个部分，竟然被一个普通字段决定了。 | **主键(学生, 老师)：** 张三，王老师(教数学) *(规定：一个老师只教一门课。在此表中，老师决定了课程，但老师不是主键，课程却是主键的一部分)* | **拆表：** 表1：老师 -> 课程 表2：学生, 老师           |
| **4NF**  | **拒绝乱点鸳鸯谱** (消灭独立多值依赖)     | **强行凑对** 两组互不相干的“多对多”硬塞在一起。              | **主键(全属性)：** 数学课，王老师，教材A 数学课，李老师，教材B *(老师和教材无关，却被迫排列组合)* | **拆表：** 表1：课程 -> 老师列表 表2：课程 -> 教材列表 |

# 填充因子

| **场景**                                     | **填充因子建议**       | **为什么？**                                                 |
| -------------------------------------------- | ---------------------- | ------------------------------------------------------------ |
| **只读表 / 历史归档** (数据写进去就不改了)   | **100%**               | 既然以后**不会再往中间插数据**，那就没必要留空隙。塞满它，最省空间，读取效率也最高（因为翻页次数少）。 |
| **高频更新表 / 交易表** (经常插入、修改数据) | **较低值 (如 70-80%)** | 因为数据经常变动，必须**预留缓冲区**。如果不留空，每次插入都会触发“搬书”（页拆分），数据库会卡顿，性能会下降。 |

# 聚集索引和非聚集索引

### 1. 聚集索引 (Clustered Index)

**核心比喻：字典的正文**

想象你手里有一本《新华字典》。

- 如果你想查“爱”字，你不需要看目录，因为字典的正文本身就是按照拼音（a, b, c...）**物理排序**排好的。
- 翻到 'A' 开头的那几页，你直接就能找到“爱”字以及它的详细解释。

**在数据库里：**

- **物理存储：** 只有聚集索引，数据行在硬盘上的**物理存储顺序**才和索引顺序是一致的。
- **叶子节点：** 索引的叶子节点**就是数据本身**（找到了索引就找到了数据）。
- **数量限制：** 一张表**只能有一个**聚集索引。（因为物理上书只能有一种摆法，不可能既按拼音排，又按笔画排）。
- **默认情况：** 通常这就是你的**主键 (Primary Key)**。

### 2. 非聚集索引 (Non-Clustered Index)

**核心比喻：教科书背后的“关键词索引”**

想象你有一本《数据库原理》教材。

- 正文是按照章节（第一章、第二章...）写的，这叫聚集索引。
- 书的最后通常有一个“术语索引表”。如果你想查“第四范式”在哪里：
  1. 你去书背后的索引表找到“第四范式”。
  2. 索引表告诉你：“在第 88 页”。
  3. 你还需要**翻到第 88 页**（回到正文）才能看到具体内容。

**在数据库里：**

- **逻辑存储：** 索引的顺序和数据物理存放的顺序**无关**。
- **叶子节点：** 索引的叶子节点存的是**指针**（或者是主键的值），它指向数据真正所在的位置。
- **数量限制：** 一张表可以有**很多个**非聚集索引。（就像书后面可以有“术语索引”、“人名索引”等等）。
- **回表 (Lookups)：** 如果查询的内容索引里没有，需要根据指针去正文里找数据的过程，叫**回表**（稍微慢一点）。

### 3. 极简对比表

| **特性**     | **聚集索引 (Clustered)**              | **非聚集索引 (Non-Clustered)**       |
| ------------ | ------------------------------------- | ------------------------------------ |
| **生活比喻** | **字典的正文** (拼音排序)             | **书后的索引页** (关键词 -> 页码)    |
| **物理顺序** | 数据就是按这个顺序存的                | 数据乱放，索引单独建个目录           |
| **数量限制** | **唯我独尊** (每张表只能有 1 个)      | **多多益善** (可以有多个)            |
| **存什么？** | 叶子节点 = **整行数据**               | 叶子节点 = **指向数据的地址** (指针) |
| **速度**     | **极快** (找到就是拿到了)             | **较快** (可能需要多一步“回表”操作)  |
| **适用场景** | 范围查询 (比如找 2020年-2023年的数据) | 精确查找 (比如找叫“张三”的人)        |